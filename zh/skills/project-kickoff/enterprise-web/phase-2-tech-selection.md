# Phase 2: 技术选型阶段

> **阶段目标**: 确定技术栈、架构风格、部署方案  
> **产出物**: 技术选型文档（含选型理由）、架构图  
> **关键原则**: 给出推荐 + 理由，而非只是列出选项

---

## 1. 选型原则

### 1.1 核心原则

| 原则 | 说明 | 优先级 |
|------|------|:------:|
| **团队熟悉度** | 团队熟悉的技术 > 最新最酷的技术 | ⭐⭐⭐⭐⭐ |
| **技术栈一致性** | 与公司现有技术栈对齐 | ⭐⭐⭐⭐ |
| **社区与生态** | 活跃社区、丰富文档、易招人 | ⭐⭐⭐⭐ |
| **满足需求** | 刚好满足需求，不过度设计 | ⭐⭐⭐⭐ |
| **可维护性** | 长期维护成本低 | ⭐⭐⭐ |

### 1.2 反模式警示

| 反模式 | 表现 | 后果 |
|--------|------|------|
| **简历驱动开发** | 为了学新技术而选新技术 | 团队效率低，项目风险高 |
| **过度设计** | 10 人用的系统上微服务 | 开发运维成本爆炸 |
| **技术执念** | "必须用 XX 因为它最好" | 忽视团队实际情况 |
| **跟风** | "大厂都在用 XX" | 不适合自己的场景 |

---

## 2. 决策框架

### 2.1 后端语言决策树

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         后端语言决策树                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Q1: 团队最熟悉什么语言？                                                    │
│  ├── 有明确偏好 ────────────────────────────────────► 使用团队熟悉的语言    │
│  └── 没有特别偏好 / 新团队 ─────────────────────────► Q2                   │
│                                                                             │
│  Q2: 项目有特殊需求吗？                                                      │
│  ├── 需要与 AI/ML 模型集成 ─────────────────────────► Python 🏆            │
│  ├── 需要极致性能（高并发计算）──────────────────────► Go / Rust           │
│  ├── 需要与 Java 生态集成 ──────────────────────────► Java                 │
│  ├── 前后端统一语言 ────────────────────────────────► Node.js (TypeScript) │
│  └── 没有特殊需求 ──────────────────────────────────► Q3                   │
│                                                                             │
│  Q3: 项目规模和团队情况？                                                    │
│  ├── 小团队 + 快速迭代 ─────────────────────────────► Python / Node.js     │
│  ├── 中大型团队 + 企业项目 ─────────────────────────► Java / C#            │
│  └── 追求开发效率 + 性能平衡 ───────────────────────► Go                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 后端语言对比矩阵

| 维度 | Python | Node.js | Java | Go |
|------|:------:|:-------:|:----:|:--:|
| **开发效率** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **运行性能** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **AI/ML 生态** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **Web 框架成熟度** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **招聘难度** | 容易 | 容易 | 容易 | 中等 |
| **适合场景** | API服务、AI集成 | I/O密集、全栈 | 大型企业系统 | 高并发服务 |

### 2.3 后端框架推荐

| 语言 | 推荐框架 | 适用场景 | 备选 |
|------|----------|----------|------|
| **Python** | FastAPI | API 优先、现代异步 | Django (全栈)、Flask (轻量) |
| **Node.js** | NestJS | 企业级、结构化 | Express (灵活)、Koa (轻量) |
| **Java** | Spring Boot | 企业级标准 | Quarkus (云原生) |
| **Go** | Gin | 轻量高性能 | Echo、Fiber |

---

### 2.4 数据库决策树

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          数据库决策树                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Q1: 数据结构是什么类型？                                                    │
│  ├── 结构化数据（表格、关系）─────────────────────► 关系型数据库 (Q2)       │
│  ├── 文档型（JSON、嵌套结构）─────────────────────► MongoDB                 │
│  ├── 键值对 / 缓存 ───────────────────────────────► Redis                  │
│  ├── 图关系 ──────────────────────────────────────► Neo4j                  │
│  └── 时序数据 ────────────────────────────────────► InfluxDB / TimescaleDB │
│                                                                             │
│  Q2: 关系型数据库选择                                                        │
│  ├── 公司已有 MySQL ──────────────────────────────► MySQL 🏆               │
│  ├── 公司已有 PostgreSQL ─────────────────────────► PostgreSQL             │
│  ├── 需要高级功能（JSON、全文搜索）───────────────► PostgreSQL 🏆          │
│  ├── 云原生 / 无服务器 ───────────────────────────► 云数据库               │
│  └── 简单项目 / 嵌入式 ───────────────────────────► SQLite                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.5 数据库对比矩阵

| 维度 | PostgreSQL | MySQL | MongoDB |
|------|:----------:|:-----:|:-------:|
| **功能丰富度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **JSON 支持** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **性能** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **运维难度** | 中等 | 简单 | 中等 |
| **国内普及度** | 中等 | 很高 | 中等 |

---

### 2.6 前端框架决策树

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         前端框架决策树                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Q1: 团队熟悉什么框架？                                                      │
│  ├── 熟悉 React ──────────────────────────────────► React                  │
│  ├── 熟悉 Vue ────────────────────────────────────► Vue 3                  │
│  ├── 熟悉 Angular ────────────────────────────────► Angular                │
│  └── 都不熟悉 ────────────────────────────────────► Q2                     │
│                                                                             │
│  Q2: 项目特点？                                                              │
│  ├── 追求灵活性、生态丰富 ────────────────────────► React 🏆               │
│  ├── 追求上手快、文档好（国内团队）───────────────► Vue 3 🏆               │
│  ├── 大型企业项目、强约束 ────────────────────────► Angular                │
│  └── 简单项目、少交互 ────────────────────────────► 原生或轻量方案         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.7 UI 组件库推荐

| 框架 | 推荐组件库 | 特点 | 备选 |
|------|------------|------|------|
| **React** | Ant Design | 企业级、组件丰富 | Material UI、Shadcn |
| **Vue** | Element Plus | 国内流行、文档好 | Naive UI、Vuetify |
| **Angular** | Angular Material | 官方、一致性好 | NG-ZORRO |

---

## 3. 架构决策

### 3.1 架构风格决策

| 用户量 | 推荐架构 | 说明 |
|--------|----------|------|
| < 1000 | **单体应用** | 简单可靠，一个仓库搞定 |
| 1K-10K | **模块化单体** | 单体但模块清晰，可拆分 |
| 10K-100K | **单体 + 独立服务** | 核心单体，特定功能独立 |
| > 100K | **微服务** | 需要成熟的团队和基础设施 |

### 3.2 必须遵循的架构原则

| 原则 | 说明 | 实践 |
|------|------|------|
| **分层** | 表现层、业务层、数据层分离 | Controller → Service → Repository |
| **依赖倒置** | 高层不依赖低层，都依赖抽象 | 定义 Interface |
| **配置外部化** | 配置与代码分离 | 环境变量、配置文件 |
| **关注点分离** | 一个模块只做一件事 | 单一职责 |

### 3.3 必须抽象的外部依赖

以下外部依赖**必须通过接口抽象**，便于未来切换：

```python
# ✅ 正确：通过接口抽象
class IEmailService(ABC):
    @abstractmethod
    async def send(self, to: str, subject: str, body: str): ...

class SMTPEmailService(IEmailService): ...    # 当前实现
class SendGridEmailService(IEmailService): ... # 未来可切换

# ❌ 错误：直接依赖具体实现
class UserService:
    def __init__(self):
        self.smtp = smtplib.SMTP('smtp.example.com')  # 写死了！
```

**必须抽象的服务清单：**

| 服务类型 | 当前可能实现 | 未来可能切换 |
|----------|--------------|--------------|
| 邮件服务 | SMTP | SendGrid、AWS SES |
| 文件存储 | 本地文件系统 | MinIO、S3、OSS |
| 消息队列 | Redis | RabbitMQ、Kafka |
| 认证服务 | 本地 JWT | SSO、OAuth |
| 短信服务 | 阿里云 | 腾讯云、Twilio |
| 支付服务 | 支付宝 | 微信支付、Stripe |

---

## 4. 安全相关决策

### 4.1 认证方案

| 方案 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| **JWT** | API 优先、前后端分离 | 无状态、易扩展 | Token 撤销复杂 |
| **Session** | 传统 Web 应用 | 简单、可立即撤销 | 需要 Session 存储 |
| **OAuth 2.0** | 第三方登录 | 标准化 | 实现复杂 |

**推荐：JWT + Refresh Token**

```
Access Token:  短期有效（15-30 分钟），存内存
Refresh Token: 长期有效（7-30 天），存 httpOnly Cookie
```

### 4.2 密码存储

| 方案 | 推荐度 | 说明 |
|------|:------:|------|
| **bcrypt** | ⭐⭐⭐⭐⭐ | 业界标准，自带盐值 |
| **Argon2** | ⭐⭐⭐⭐⭐ | 更新更安全，推荐 Argon2id |
| **PBKDF2** | ⭐⭐⭐ | 可用但较老 |
| MD5/SHA1 | ❌ | **绝对禁止** |

### 4.3 敏感数据加密

| 数据类型 | 加密方式 | 说明 |
|----------|----------|------|
| 密码 | bcrypt/Argon2 (Hash) | 不可逆 |
| 敏感字段 | AES-256-GCM | 可逆，需要时解密 |
| 传输 | TLS 1.2+ | HTTPS |
| 数据库 | TDE (可选) | 透明数据加密 |

---

## 5. 部署相关决策

### 5.1 容器化决策

| 场景 | 推荐方案 |
|------|----------|
| 开发环境 | Docker Compose |
| 小规模生产 | Docker Compose + Watchtower |
| 中规模生产 | Docker Swarm 或 K3s |
| 大规模生产 | Kubernetes |

### 5.2 云服务 vs 自建

| 服务 | 建议 | 理由 |
|------|------|------|
| 数据库 | 云数据库优先 | 免运维、自动备份 |
| 缓存 | 云 Redis 优先 | 高可用、免运维 |
| 对象存储 | 云存储优先 | 无限扩展、CDN |
| 应用服务器 | 看情况 | 容器或 Serverless |

**例外**：如果有合规要求必须本地部署，则自建。

---

## 6. Agent 输出模板

技术选型完成后，按以下格式输出：

```markdown
# [项目名称] - 技术选型文档

## 1. 技术栈总览

| 层级 | 选型 | 版本 |
|------|------|------|
| 后端语言 | [选型] | [版本] |
| 后端框架 | [选型] | [版本] |
| 数据库 | [选型] | [版本] |
| 前端框架 | [选型] | [版本] |
| UI 组件库 | [选型] | [版本] |
| ... | ... | ... |

## 2. 选型理由

### 2.1 后端语言：[选型]

**选择理由**：
- [理由 1]
- [理由 2]

**备选方案**：
- [备选 1]：未选择因为 [原因]

### 2.2 数据库：[选型]

...（同上格式）

## 3. 架构设计

### 3.1 整体架构图

[架构图]

### 3.2 分层说明

...

## 4. 安全方案

### 4.1 认证方案
### 4.2 加密方案
### 4.3 其他安全措施

## 5. 部署方案

### 5.1 部署架构
### 5.2 环境规划

## 6. 开发规范

### 6.1 目录结构
### 6.2 编码规范
### 6.3 Git 工作流
```

---

## 7. 检查清单

技术选型完成前，确保以下问题都已回答：

### 必答问题

- [ ] 后端语言和框架？为什么选这个？
- [ ] 数据库？为什么选这个？
- [ ] 前端框架和 UI 库？为什么选这个？
- [ ] 认证方案？JWT 还是 Session？
- [ ] 密码怎么存储？
- [ ] 敏感数据怎么加密？
- [ ] 部署在哪里？怎么部署？
- [ ] 外部服务（邮件、存储等）是否做了抽象？

### 进阶问题

- [ ] 如果用户量增长 10 倍，架构能支撑吗？
- [ ] 如果需要切换数据库，代码改动大吗？
- [ ] 如果需要接入 SSO，需要改多少代码？
- [ ] 如果核心开发者离职，新人能接手吗？

---

## 版本历史

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v1.0 | 2025-01-27 | 初始版本 |
